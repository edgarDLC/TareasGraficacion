CREACION DE QR DESDE CERO
1.Estándar QR: Debes familiarizarte con la norma ISO/IEC 18004 que especifica cómo funcionan los códigos QR.

2.Estructura básica de un QR:
-Patrones de posición (los cuadrados grandes en las esquinas)
-Patrones de alineamiento (cuadrados más pequeños)
-Timing patterns (líneas alternadas)
-Zona de datos
-Zona de información de formato y versión

3.Codificación de datos:
-Modos de codificación (numérico, alfanumérico, byte, kanji)
-Codificación Reed-Solomon para corrección de errores
-Máscaras y formatos para optimizar la legibilidad


PASOS PARA IMPLEMENTAR
1.Determinar parámetros:
-Versión del QR (tamaño)
-Nivel de corrección de errores (L, M, Q, H)

2.Codificar los datos:
-Añadir modo de codificación y conteo de caracteres
-Convertir datos a bits según el modo seleccionado
-Dividir en bloques para corrección de errores

3.Generar código de corrección:
-Implementar algoritmo Reed-Solomon

4.Construir matriz:
-Colocar patrones fijos
-Disponer los datos y códigos de corrección
-Aplicar máscara óptima

5.Representación visual:
-Convertir la matriz de bits a píxeles visibles

//https://www.youtube.com/watch?v=4XTkiudd-_E

/*   GENERADOR DE QR
El programa funciona de la siguiente manera:
Se usa una matriz para representar al QR versión 2 25x25
Se definen los patrones de posición y luego se insertan en la matriz
Se define él patrón de alineamiento y luego se insertan en la matriz
Se definen los patrones formato y versión y luego se insertan en la matriz
Se definen el patrón de sepador de los patrones de posición  y luego se insertan en la matriz
Se extrae el URL del HTML, se determina su tamaño, se convierte a bytes y se define el modo byte
Se rellena la matriz con el formato de byte, el tamaño en bytes y el URL en bytes usando el patrón zig-zag.
Mediante el método fillRect se procede a dibujar los cuadrados del QR.
*/
export class CanvasLocal {
  //atributos
  protected graphics: CanvasRenderingContext2D;
  protected rWidth:number; //ancho
  protected rHeight:number; //alto
  protected maxX: number; 
  protected maxY: number; 
  protected pixelSize: number;
  protected centerX: number;
  protected centerY: number;
  protected fontSize: number = 16;
      
  public constructor(g: CanvasRenderingContext2D, canvas: HTMLCanvasElement){
    this.graphics = g;
    this.rWidth = 12;
    this.rHeight= 8;
    this.maxX = canvas.width - 1; 
    this.maxY = canvas.height - 1;
    this.pixelSize = Math.max(this.rWidth / this.maxX, this.rHeight / this.maxY);
    this.centerX = this.maxX/12;
    this.centerY = this.maxY/8*7;
    this.fontSize = 16;
  }

  iX(x: number):number{return Math.round(this.centerX + x/this.pixelSize);}
  iY(y: number):number{return Math.round(this.centerY - y / this.pixelSize); }

  drawLine(x1: number, y1: number, x2: number, y2:number) { 
    this.graphics.beginPath();
    this.graphics.moveTo(x1, y1);
    this.graphics.lineTo(x2, y2);
    this.graphics.closePath();
    this.graphics.stroke();
  }

  //éetodo para trazar trazar y rellenar el QR
  TrazarYRellenar(matrizQR: number[][]) {
    const size = matrizQR.length ;
    const moduleSize = 15; // Tamaño en píxeles de cada módulo QR
    
    // Definir colores
    const colors = {
        0: '#FFFFFF', // Blanco para 0
        1: '#000000', // Negro para 1
        4: '#87CEEB', // Azul cielo para 4
        3: '#A41E01', //' Marron para 3 no usado
        7: '#FFFFFF'  // Blanco para separadores 7
    };

    // Limpiar canvas
    this.graphics.clearRect(0, 0, this.maxX, this.maxY);
    
    // Dibujar cada módulo del QR
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const value = matrizQR[y][x];
            const color = colors[value] || '#FFFFFF'; 
            
            // Calcular posición en canvas
            const canvasX = 100 + x * moduleSize-0.5;
            const canvasY = 100 + y * moduleSize-0.5;
            
            
            this.graphics.fillStyle = color;
            //this.graphics.fillRect(X, Y, ancho, altura);
            this.graphics.fillRect(canvasX, canvasY, moduleSize, moduleSize);
            this.graphics.strokeStyle = '#EEEEEE';
            this.graphics.strokeRect(canvasX, canvasY, moduleSize, moduleSize);
        }
    }  
}
  
  //Metodo que repite el simbolo de posicionamiento en la matriz en las 3 esquinas
  rellenarMatrizPosicion(filas: number, columnas: number): number[][] {
    const matriz: number[][] = [];
    for (let i = 0; i < filas; i++) {
        matriz[i] = Array(columnas).fill(3);
    }

    // Patrón de posicionamiento
    const patronPosicion = [
      [1, 1, 1, 1, 1, 1, 1], 
      [1, 0, 0, 0, 0, 0, 1], 
      [1, 0, 1, 1, 1, 0, 1], 
      [1, 0, 1, 1, 1, 0, 1], 
      [1, 0, 1, 1, 1, 0, 1], 
      [1, 0, 0, 0, 0, 0, 1], 
      [1, 1, 1, 1, 1, 1, 1]  
    ];

    // Función auxiliar para colocar el patrón en una posición específica
    const colocarPatron = (filaInicio: number, columnaInicio: number) => {
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < 7; j++) {
                if (filaInicio + i <filas && columnaInicio + j < columnas) {
                    matriz[filaInicio + i][columnaInicio + j] = patronPosicion[i][j];
                }
            }
        }
    };
    
    // Arriba izquierda 
    colocarPatron(0, 0);
    
    // Arriba derecha 
    colocarPatron(0, columnas - 7);
    
    // Abajo izquierda 
    colocarPatron(filas - 7, 0);

    return matriz;
  }

  rellenarMatrizAlineamiento(matrizQR: number[][]): number[][] {
    const matriz = [...matrizQR]; // Copia de matriz
    // Patron de alineamiento
    const patronAlineamiento = [
      [1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1],
      [1, 0, 1, 0, 1],
      [1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1]  
    ];

    const inicioX = 16;
    const inicioY = 16;
    
    // Se aplica patrón
    for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            if (inicioX + i < matriz.length && inicioY + j < matriz[0].length) {
                matriz[inicioX + i][inicioY + j] = patronAlineamiento[i][j];
            }
        }
    }
    
    return matriz;
}


rellenarMatrizFormatoVersion(matrizQR: number[][]): number[][] {
  const matriz = [...matrizQR];

  // Patron de formato arriba izquierda
  for (let i = 0; i <= 8; i++) {
       matriz[8][i] = 4;//4
       matriz[i][8] = 4;//4
  }
  
  // Patron de formato arriba derecha
  for (let i = 17; i < 25; i++) {
       matriz[8][i] = 4;//4
  }

  // 3. Patron de formato abajo izquierda
  for (let i = 17; i < 25; i++) {
       matriz[i][8] = 4;//4
  }

  return matriz;
}

rellenarMatrizSepadadorPatronesPosicion(matrizQR: number[][]): number[][] {
  const matriz = [...matrizQR];

  // Formato separador de patron de posicion
  for (let i = 0; i < 8; i++) {//vertical
    matriz[i][7] = 0; 
    matriz[i][17] = 0; 
    matriz[i+17][7] = 0;
  }

  for (let i = 0; i < 8; i++) {//horizontal
    matriz[7][i] = 0;
    matriz[7][i+17] = 0;
    matriz[17][i] = 0;
    
  }

  return matriz;
}

convertirUrlABytes(tamano: number, url: string): string {
  // Convertir el tamaño a binario (8 bits)
  const tamanoBinary = (tamano & 0xFF).toString(2).padStart(8, '0');
  
  // Convertir la URL a bytes (binario), cada carácter como 8 bits
  let urlBinary = '';
  for (let i = 0; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    const byte = charCode & 0xFF; 
    urlBinary += byte.toString(2).padStart(8, '0');
  }
  
  const resultado = tamanoBinary + urlBinary;
  return resultado;
}

rellenarMatrizBytes(matrizQR: number[][], union: string): number[][] {
  const matriz = [...matrizQR];
  const size = matriz.length;
  let bitInicio = 0;
  
  // Definir areas reservadas que no deben modificarse
  const areasReservadas = this.areasReservadas(size);

  // Patrón de llenado en zig-zag
  for (let col = size - 1; col >= 0; col -= 2) {
    if (col === 6) col--; 
    
    // Movimiento hacia arriba
    if ((size - col) % 4 === 1 || (size - col) % 4 === 0) {
      for (let row = size - 1; row >= 0; row--) {
        if (this.esAreaModificable(row, col, areasReservadas, matriz)) {
          if (bitInicio < union.length) {
            matriz[row][col] = parseInt(union[bitInicio]);
            bitInicio++;
          }
        }
        
        // Columna adyacente (derecha)
        if (col > 0 && this.esAreaModificable(row, col - 1, areasReservadas, matriz)) {
          if (bitInicio < union.length) {
            matriz[row][col - 1] = parseInt(union[bitInicio]);
            bitInicio++;
          }
        }
      }
    } 
    // Movimiento hacia abajo
    else {
      for (let row = 0; row < size; row++) {
        if (this.esAreaModificable(row, col, areasReservadas, matriz)) {
          if (bitInicio < union.length) {
            matriz[row][col] = parseInt(union[bitInicio]);
            bitInicio++;
          }
        }
        
        // Columna adyacente (derecha)
        if (col > 0 && this.esAreaModificable(row, col - 1, areasReservadas, matriz)) {
          if (bitInicio < union.length) {
            matriz[row][col - 1] = parseInt(union[bitInicio]);
            bitInicio++;
          }
        }
      }
    }
  }
  
  return matriz;
}

private areasReservadas(size: number): boolean[][] {
  const reservadas = Array(size).fill(null).map(() => Array(size).fill(false));
  
  // Patrones de posición 
  for (let i = 0; i < 7; i++) {
    for (let j = 0; j < 7; j++) {
      reservadas[i][j] = true;
      reservadas[i][size - 1 - j] = true;
      reservadas[size - 1 - i][j] = true;
    }
  }
  
  // Patrón de alineamiento 
  for (let i = 16; i < 21; i++) {
    for (let j = 16; j < 21; j++) {
      reservadas[i][j] = true;
    }
  }
  
  // Linea de formato y versión
  for (let i = 0; i < 9; i++) {
    reservadas[i][8] = true; // Vertical izquierda
    reservadas[8][i] = true; // Horizontal arriba
    if (i < 8) {
      reservadas[8][size - 1 - i] = true; // Horizontal arriba derecha
      reservadas[size - 1 - i][8] = true; // Vertical abajo izquierda
    }
  }
  
  // Separadores
  for (let i = 0; i < 8; i++) {
    reservadas[i][7] = true;
    reservadas[i][17] = true;
    reservadas[i+17][7] = true;
    reservadas[7][i] = true;
    reservadas[7][i+17] = true;
    reservadas[17][i] = true;
  }
  
  return reservadas;
}

//verificación si es modificable o es area reservada
private esAreaModificable(row: number, col: number, reservadas: boolean[][], matriz: number[][]): boolean {
  return !reservadas[row][col] && (matriz[row][col] === 3 || matriz[row][col] === 0 || matriz[row][col] === 1);
}

mostrarMatrizEnConsola(matriz: number[][]) {
  console.log("Matriz QR (25x25):");
  console.log("----------------------------------------");
  let fila = "";
  for (let i = 0; i < matriz.length; i++) {
      for (let j = 0; j < matriz[i].length; j++) {
          fila += matriz[i][j] + " ";
      }
      fila += "\n";
  }
  console.log(fila);
  console.log("----------------------------------------");
}
  

  paint(url?: string) {

    // rellenar con los patrones de posicion
    let matrizQR: number[][] = this.rellenarMatrizPosicion(25, 25);

    // rellenar con el patrón de alineamiento
    matrizQR = this.rellenarMatrizAlineamiento(matrizQR);

    // rellenar área de formato y versión
    matrizQR = this.rellenarMatrizFormatoVersion(matrizQR);

    // rellenar separador de patrones de posicion
    matrizQR = this.rellenarMatrizSepadadorPatronesPosicion(matrizQR);

    // convertir URL a bytes
    if (url) {
      console.log("URL: ", url);
      const tamano = url.length;
      const urlBytes = this.convertirUrlABytes(tamano, url);      

      const modo = "0100"; // Modo Byte
      const union = modo + tamano + urlBytes;
      console.log(union);

      //Método para rellenar la matriz con los bytes del URL
      matrizQR = this.rellenarMatrizBytes(matrizQR, union);
    }
    //Mostrar la matriz en consola
    this.mostrarMatrizEnConsola(matrizQR);

    //Se procede a crear el QR
    this.TrazarYRellenar(matrizQR);

  }
}